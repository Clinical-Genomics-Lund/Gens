<!doctype html>
    <head>
        <link rel="stylesheet" href="static/css/flexboxgrid.min.css" type="text/css">
        <link rel="stylesheet" href="static/css/cov.css" type="text/css">
        <script src="{{ url_for('static', filename='js/jquery-3.1.1.min.js') }}"></script>
    </head>

    <body>
        <div class="grid-container">
            <div id="canvas-container" width="1000" height="500">
            </div>

            <div id="button-container">
                <form method="POST" id="region_form" action="{{url_for('coverage_view')}}">
                    <input name="region" type="text" size=20>
                    <input type="submit">
                </form>

                <button onclick="left();">left</button>
                <button onclick="right();">right</button>
                <button onclick="zoom_in();">+</button>
                <button onclick="zoom_out();">-</button>
            </div>
        </div>

    </body>

    <script>
        $SCRIPT_ROOT = {{ request.script_root|tojson|safe }};

        function createCanvas(canvas_width, canvas_height) {
            var canvas = document.createElement('canvas');
            canvas.width = canvas_width;
            canvas.height = canvas_height;
            document.getElementById("canvas-container").appendChild(canvas);
            return canvas;
        }

        function draw_static_coord_box(canvas, cvar) {
            let ctx = canvas.getContext("2d");

            // Set colour of whole canvas
            ctx.save();
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            // Function draws a static coordinate system
            let draw_coord_lines = function(start, end, fraction,
                                            top_padding, top_offset) {
                var position = 0;
                var step = cvar.box_height / ((start - end) / fraction);

                // Draw boundingbox and clear it from colour
                ctx.lineWidth = 2;
                ctx.clearRect(cvar.left_padding, top_padding - top_offset,
                              cvar.box_width, cvar.box_height + top_offset);
                ctx.rect(cvar.left_padding, top_padding, cvar.box_width, cvar.box_height);
                ctx.stroke();

                // Draw lines and values for Y-axis
                for (let i = start.toFixed(1); i >= end; i = (i - fraction).toFixed(1)) {
                    let ypos = top_padding + position;

                    ctx.beginPath();

                    // Draw a tick mark for values
                    ctx.moveTo(cvar.left_padding - cvar.tick_len / 2, ypos);
                    ctx.lineTo(cvar.left_padding + cvar.tick_len / 2, ypos);
                    ctx.stroke();

                    // Draw a transparent line across box
                    if (i != start && i != end) {
                        ctx.save();
                        ctx.lineWidth = cvar.tick_width;
                        ctx.strokeStyle = cvar.line_colour;
                        ctx.moveTo(cvar.left_padding, ypos);
                        ctx.lineTo(cvar.left_padding + cvar.box_width, ypos);
                        ctx.stroke();
                        ctx.restore();

                    }

                    // Draw Y-axis value
                    ctx.font = "12px Arial";
                    ctx.fillText(i, 25, ypos + 4);
                    position += step;
                }
            }

            // Draw BAF context
            draw_coord_lines(cvar.baf_start, cvar.baf_end, cvar.baf_frac,
                             cvar.baf_padding, cvar.top_offset);

            // Draw LogR context
            draw_coord_lines(cvar.logr_start, cvar.logr_end, cvar.logr_frac,
                             cvar.logr_padding, 0);

            // Draws rotated text
            let draw_rotated_text = function(text, posx, posy) {
                ctx.save();
                ctx.font = "18px Arial";
                ctx.translate(posx, posy); // Position for text
                ctx.rotate(-Math.PI/2); // Rotate 90 degrees
                ctx.textAlign = 'center';
                ctx.fillText(text, 0, 9);
                ctx.restore();
            }

            // Draw rotated y-axis legends
            draw_rotated_text("B Allele Freq", 10, cvar.baf_padding + cvar.box_height / 2);
            draw_rotated_text("Log R Ratio", 10, cvar.logr_padding + cvar.box_height / 2);
        }


        class GeneCanvas {
            constructor(canvas_width, canvas_height) {
                // Canvas variables
                this.cvar = {
                    // Box values
                    left_padding: 50,
                    top_offset: 25,
                    box_width: canvas_width,
                    box_height: canvas_height / 2,
                    tick_len: 6,
                    tick_width: 0.2,
                    line_colour: "#000000",

                    // BAF values
                    baf_start: 1.0,
                    baf_end: 0.0,
                    baf_frac: 0.2,
                    baf_padding: 45,

                    // LogR values
                    logr_start: 4.0,
                    logr_end: -4.0,
                    logr_frac: 1.0,
                    logr_padding: 0
                }
                this.cvar.logr_padding = this.cvar.baf_padding + this.cvar.box_height - 20;
                this.cvar.box_width -= this.cvar.left_padding;
                this.cvar.box_height = (canvas_height - this.cvar.top_offset - this.cvar.baf_padding) / 2;

                // Create canvas for data
                this.dataCanvas = createCanvas(canvas_width, canvas_height);
                this.dataCanvas.id = "dataCanvas";

                this.drawCanvas = createCanvas(canvas_width, canvas_height);
                this.drawCanvas.id = "drawCanvas";

                // Create static canvas
                this.staticCanvas = createCanvas(canvas_width, canvas_height);
                this.staticCanvas.id = "staticCanvas";
                draw_static_coord_box(this.staticCanvas, this.cvar);
            }
        }

        let chrom = "{{chrom}}";
        let start = {{start}};
        let end   = {{end}};

        let call_chrom = "{{call_chrom}}";
        let call_start = {{call_start}};
        let call_end   = {{call_end}};

        var gc = new GeneCanvas(1000, 500);
        var ctx = gc.dataCanvas.getContext("2d");

        function draw_coverage(data, baf) {
            let ch = data[0][0];
            let scale = gc.drawCanvas.width / (end - start);
            let xaxis_tick_frq = Math.pow(10, (end - start).toString().length - 2);
            let xaxis_tick = Math.ceil(start / xaxis_tick_frq) * xaxis_tick_frq;
            let every_other = false;

            let title_offset = 30; // Offset from top padding
            let x_axis_offset = 10; // Offset from top padding

            // Draw on empty temporary canvas
            var drawCanvas = gc.drawCanvas.getContext("2d");
            drawCanvas.clearRect(0, 0, gc.drawCanvas.width, gc.drawCanvas.height);

            // Draw chromosome title
            let txt = "Chromosome " + chrom;
            let txt_width = 110;
            gc.staticCanvas.getContext("2d").clearRect(0, 0,
                    gc.cvar.box_width, gc.cvar.baf_padding - gc.cvar.top_offset);
            gc.staticCanvas.getContext("2d").font = "bold 14px Arial";
            gc.staticCanvas.getContext("2d").fillText(txt,
                    gc.cvar.left_padding + gc.cvar.box_width / 2 - txt_width / 2,
                    gc.cvar.baf_padding - title_offset);

            drawCanvas.font = "9px Arial";

            if (((end - start) / xaxis_tick_frq) > 15 ) {
                every_other = true;
            }

            // Draw x-axis tick value
            let counter = 0;
            let prev_xpos = 0;
            while (xaxis_tick < end) {
                drawCanvas.fillRect(scale * (xaxis_tick - start),
                                    gc.cvar.baf_padding - 2,
                                    2, 5);
                counter++;
                // Only draw value on every other tick
                txt = numberWithCommas(xaxis_tick);
                txt_width = drawCanvas.measureText(txt).width;
                let tick_xpos = scale * (xaxis_tick - start) - txt_width / 2;
                if((!every_other || counter % 2 == 0) && (tick_xpos - prev_xpos) > (txt_width + 5)) {
                    drawCanvas.fillText(txt, tick_xpos, gc.cvar.baf_padding - 10);
                    prev_xpos = tick_xpos;
                }
                xaxis_tick += xaxis_tick_frq;
            }
            console.log(ch, start, end, (end - start), data.length);

            // Draw BAF values
            let ampl = gc.cvar.box_height;
            let padding = gc.cvar.baf_padding + gc.cvar.box_height;
            drawCanvas.fillStyle = "#FF0000";
            for (let i = 0; i < baf.length - 1; i++) {
                drawCanvas.fillRect(scale * (baf[i][1] - start),
                                    padding - ampl * baf[i][3], 2, 2);
            }

            drawCanvas.fillStyle = "#000000";
            if (chrom == call_chrom && (start < call_end && end > call_start)) {
                drawCanvas.fillRect(scale * (call_start - start),
                                    120, scale * (call_end - call_start), title_offset);
                console.log("DRAW_CALL");
            }

            // Draw Log R ratio values
            ampl = gc.cvar.box_height / (2 * gc.cvar.logr_start);
            padding = gc.cvar.logr_padding + gc.cvar.box_height / 2;
            if (data.length > 1000) {
                for (let i = 0; i < data.length - 1; i++) {
                    drawCanvas.fillRect(scale * (data[i][1] - start),
                    padding - ampl * data[i][3], 2, 2);
                }
            } else {
                drawCanvas.beginPath();
                drawCanvas.moveTo(0, padding - ampl * data[0][3]);
                for (let i = 1; i < data.length - 1; i++) {
                    drawCanvas.lineTo(scale * (data[i][1] - start),
                                      padding - ampl * data[i][3], 2, 2);
                }
                drawCanvas.stroke();
            }

            gc.dataCanvas.getContext("2d").clearRect(0, 0,
                                                     gc.dataCanvas.width,
                                                     gc.dataCanvas.height);
            gc.dataCanvas.getContext("2d").drawImage(gc.drawCanvas, 0, 0);
        }

        draw_coverage({{data|safe}}, {{baf|safe}});

        function left() {
            let size = end - start;
            start -= Math.floor(0.1 * size);
            end -= Math.floor(0.1 * size);
            redraw();
        }
        function right() {
            let size = end - start;
            start += Math.floor(0.1 * size);
            end += Math.floor(0.1 * size);
            redraw();
        }
        function zoom_in() {
            let size = end - start;
            start += Math.floor(size * 0.25);
            end -= Math.floor(size * 0.25);
            redraw();
        }
        function zoom_out() {
            let size = end - start;
            start -= Math.floor(size * 0.5);
            end += Math.floor(size * 0.5);
            if (start < 1) {
                start = 1;
            }
            redraw();
        }

        function redraw() {
            $.getJSON($SCRIPT_ROOT + '/_getcov', {
                region: chrom + ":" + start + "-" + end,
            }, function(result) {
                draw_coverage(result["data"], result["baf"]);
            }).done (function() { disallow_drag = false; });
        }



        var drag = false;
        var disallow_drag = false;
        var dragStart;
        var dragEnd;

        gc.dataCanvas.addEventListener('mousedown', function(event) {
            if (!disallow_drag) {
                dragStart = {
                    x: event.pageX - gc.dataCanvas.offsetLeft,
                    y: event.pageY - gc.dataCanvas.offsetTop
                }
                dragEnd = {
                    x: event.pageX - gc.dataCanvas.offsetLeft,
                    y: event.pageY - gc.dataCanvas.offsetTop
                }
                drag = true;
            }
        });

        gc.dataCanvas.addEventListener('mousemove', function(event) {
            if (drag && !disallow_drag) {
                dragEnd = {
                    x: event.pageX - gc.dataCanvas.offsetLeft,
                    y: event.pageY - gc.dataCanvas.offsetTop
                }
                ctx.clearRect(0, 0, gc.dataCanvas.width, gc.dataCanvas.height);
                ctx.drawImage(gc.drawCanvas,
                              0,
                              0,
                              gc.drawCanvas.width,
                              gc.drawCanvas.height,
                              dragEnd.x - dragStart.x,
                              0,
                              gc.drawCanvas.width,
                              gc.drawCanvas.height);
            }
        });

        gc.dataCanvas.addEventListener('mouseup', function(event) {
            if (drag) {
                drag = false;
                let scale = gc.dataCanvas.width / (end - start);
                let move_dist = Math.floor((dragStart.x - dragEnd.x) / scale);
                if (start + move_dist < 0 ) {
                    move_dist -= (start + move_dist);
                }
                start += move_dist;
                end += move_dist;
                disallow_drag = true;
                redraw();
            }
        });

        function numberWithCommas(x) {
            return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        document.addEventListener('DOMContentLoaded', () => {
            'use strict';

            const options = {
                eventType: 'keydown',
                keystrokeDelay: 1000
            };

            keyMapper(options);
        });

        function keyMapper (options) {
            const keystrokeDelay = options && options.keystrokeDelay || 1000;

            let state = {
                buffer: "",
                lastKeyTime: Date.now()
            };

            document.addEventListener('keydown', event => {
                const key = event.key;
                const currentTime = Date.now();
                const eventType = window.event;
                const target = eventType.target || eventType.scrElement;
                const targetTagName = (target.nodeType == 1) ? target.nodeName.toUpperCase() : "";
                let buffer = "";

                // Do not listen to keydown events for active fields
                if (/INPUT|SELECT|TEXTAREA/.test(targetTagName)) {
                    return;
                }

                if (event.keyCode == 13 &&
                    currentTime - state.lastKeyTime < keystrokeDelay) {
                    // Enter was pressed, process previous key presses.
                    if (state.buffer < 24 && state.buffer > 0) {
                        // Display new chromosome
                        chrom = state.buffer
                        redraw();
                    }
                } else if (!isFinite(key)) {
                    // Arrow keys for moving graph
                    switch(event.keyCode) {
                        case 37: // Left arrow
                            left();
                            break;
                        case 39: // Right arrow
                            right();
                            break;
                        case 38: // Up arrow
                            zoom_in();
                            break;
                        case 40: // Down arrow
                            zoom_out();
                            break;
                        default:
                            return;
                    }
                } else if (currentTime - state.lastKeyTime > keystrokeDelay) {
                    // Reset buffer
                    buffer = key;
                } else {
                    if(state.buffer.length > 1) {
                        // Buffer contains more than two digits, keep the last digit
                        buffer = state.buffer[state.buffer.length - 1] + key;
                    } else {
                        // Add new digit to buffer
                        buffer = state.buffer + key;
                    }
                }

                // Save current state
                state = {buffer: buffer, lastKeyTime: currentTime};
            });
        }

    </script>
</html>
